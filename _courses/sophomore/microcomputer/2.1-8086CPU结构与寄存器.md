---
layout: article
title: 8086CPU结构与寄存器
permalink: /courses/sophomore/microcomputer/8086CPU结构与寄存器
mathjax: false
mermaid: false
chart: false
mathjax_autoNumber: false
mode: normal
tags: 计算机原理
key: microcomputer-2.1-8086CPU结构与寄存器
show_edit_on_github: false
show_date: false
sidebar:
  nav: microcomputer
aside:
  toc: true
---

<!--more-->

受限于制造工艺，如集成电路密度和引脚数，8086的基本结构有如下特点：
1. 引脚复用。如数据可双向传输
2. 单总线、累加器结构
3. 可控三态电路（oc电路）
4. 总线分时复用

# 8086 CPU框图

<center><img src="http://file.elecfans.com/web1/M00/4F/24/o4YBAFrUSV6AbN4NAACxp7mZYQY060.jpg" style="zoom:60%"></center>

上图只是简化图。分成左右两个单元：处理单元（Execution Unit）和 总线接口单元（Bus Interface Unit）。各个部件为：
1. 算数逻辑单元 ALU. A 即 Algorithm，L 即 Logic。它只能做二进制加减乘除、清零置一等操作
2. 通用寄存器。左上角就是通用寄存器。具体作用后面会细讲。
3. 内部寄存器（段寄存器） Internal Comm. Registers 用来形成数据和地址
4. 地址加法器 Σ 用来形成地址
5. 右下角的123456 指令队列

下面是根据功能来进行更细的划分：

<center><img src="https://img-blog.csdnimg.cn/20190525090409242.JPG" style="zoom:70%"></center>

1. 总线接口部件：管理地址、数据和控制总线，完成指令预取、读写数据等总线操作
2. 指令预取部件：指令预取队列，通过总线接口部件从存储器中读取指令，放入指令队列
3. 指令译码部件：从指令队列中读取指令并译码
4. 指令执行部件：由 ALU、通用寄存器、桶形移位器等组成，完成算术逻辑运算
5. 段管理部件：对存储器进行分段管理，将逻辑地址转化成线性地址
6. 页管理部件：对存储器进行分页管理，将线性地址变换成物理地址
7. 高速缓冲部件：加速指令和数据的访问
8. 浮点运算部件：用于浮点运算

# 寄存器

临时放二进制的数据的部件就是寄存器，寄存器分为：
1. 基本寄存器
   1. 通用寄存器
   2. 指令指针寄存器
   3. 标志寄存器
   4. 段寄存器
2. 系统级寄存器
3. 调试和测试寄存器
4. 浮点寄存器

## 基本寄存器

<!--![](https://images.cnitblog.com/blog/335617/201212/23173657-4b18dd2345214b91a627dbfa2cb2cf1b.png)

![8086寄存器](/assets/images/8086寄存器.png)-->

![8086寄存器](https://i.loli.net/2020/08/09/8YzodXiZrQSIUGJ.png)

1. 通用寄存器
   1. 数据寄存器 16位 分成高H、低L各8位
      1. AX 累加器 Accumulator
      2. BX 基址~ Base
      3. CX 计数~ Count
      4. DX 数据~ Data
   2. 变址寄存器
      1. 源变址~ Source Index
      2. 目的变址~ Destination Index
   3. 指针寄存器
      1. 基址指针~ Base Point
      2. 堆栈指针~ Stack Point
2. 段寄存器
   1. 数据段 Data Segment
   2. 附加段 Extra Segment
   3. 堆栈段 Stack Segment
   4. 代码段 Code Segment
3. 控制寄存器
   1. 指令指针~ Instruction Pointer
   2. 状态标志~ Processor Statue/Flag

别看这一堆东西这么多，我们逐个分析。

### 通用寄存器

数据寄存器特好记，ABCD四个16位，每个又分成高八位、低八位两个8位寄存器，于是就有 AH/AL、BH/BL、CH/CL、DH/DL。当作为16位用时，可以放数据，也能放地址；作为8位用时，只能放数据，地址就放不下了。

* **AH&AL＝AX(accumulator)**：累加寄存器，常用于运算;在乘除等指令中指定用来存放操作数,另外,所有的I/O指令都使用这一寄存器与外界设备传送数据.
* **BH&BL＝BX(base)**：基址寄存器，常用于地址索引；
* **CH&CL＝CX(count)**：计数寄存器，常用于计数；常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.
* **DH&DL＝DX(data)**：数据寄存器，常用于数据传递。

变址和指针寄存器，看名字就知道是和地址相关的，一个个说：

1. SI 和 DI，一个源，一个目的，很显然是组合一起用的。比如字符串操作，一个指向开头，一个指向结尾；
2. SP 堆栈指针，指向栈的顶部，栈底由 SS 段寄存器来提供；
3. BP 基址指针，这个看不出是啥用的，总之指向地址，至于指向哪个地址，我们后面再讲。

这三个都是“偏移地址”，需要配合段寄存器才知道真正的地址。

### 段寄存器

段是个什么玩意呢？打个比方，查字典，咱不能直接翻到那一页，要先看开头字母是啥，然后再看后面的字母。这个开头字母就是段首，也就是段寄存器存的东西；而后面的字母也就是段内的偏移地址。两个合起来，咱才能查到地址。

代码段 CS，就是放要执行程序的段首地址。CS<<4+IP=代码地址（<<即左移）

数据段 DS，就是放数据的段首地址。DS<<4+代码中的地址=数据地址

堆栈段 SS，就是放堆栈的栈底地址。 SS<<4+SP=栈顶

附加段 ES，就是给用户自己玩的。

### 指令指针 IP

CS<<4+IP=代码地址

用户不能直接访问 IP，但可以通过其他方法修改 IP,比如中断、跳转、返回等。

### 状态标识寄存器 Flag

<center><img src="https://i.loli.net/2020/03/05/pscE6HkS2bvuAme.png" style="zoom:90%"></center>

我们从右到左逐一介绍：
```
CF：进位标志（最高位加法进1/减法借1时为1）
PF：奇偶标志（低8位中有偶个1时为1，反之为0，用来偶校验，与51相反）
AF：辅助进位标志（低4进位时为1，用于BCD码）
ZF：零标志（判断结果是否为0，防止除以0）
SF：符号标志（判断正负，即最高位0/1）
TF：陷阱标志/单步标志（单步执行）
IF：中断标志（）
DF：方向标志（正着数+1/倒着数-1）
OF：溢出标志（防止两正相加/两负相减超出最大数）
```

在这里我们要掌握的是加法与减法时的标志位，即 ZF、AF、OF、SF、PF、CF（口诀：早上跑操）。下面举个例子：

`运算`{:.success}
```
  0110 0011 0100 0101
+ 0101 0010 0001 0110
= 1011 0101 0101 1011
```

`标志位`{:.info}
```
最高位是1，所以 SF=1
结果非零，所以 ZF=0
低8位有5个1，所以 PF=0
第3位没有进位，所以 AF=0
最高位没进位/借位，所以 CF=0
两个正数相加产生了负数，所以 OF=1
```

判断溢出主要看：
1. 正+正有无产生负
2. 负+负有无产生正
3. 正-负有无产生负
4. 负-正有无产生正

也有另一种方法判断溢出，即最高位和次高位必须同时进位或同时借位，比如：如果最高位进位，但次高位没进，则为溢出。

## 系统级寄存器

## 浮点寄存器

说实话，上俩部分书上没有，所以咱也暂时不讲。


